<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>Title</title>
</head>
<body>
    <script>
        function Fn(){
            this.x = 100;
            this.y = 200;

            this.getX = function (){
                console.log(this.x);
            }
        }

        Fn.prototype.getX = function (){
            //console.log(typeof this);
            console.log(this.x);
        }

        Fn.prototype.getY = function (){
            console.log(this.y);
        }

        var f1 = new Fn;
        var f2 = new Fn;

        console.log(f1.getX === f2.getX); //false
        console.log(f1.getY === f2.getY); //true
        console.log(f1.__proto__.getY === Fn.prototype.getY ); //true
        console.log(f1.__proto__.getY === f2.getY); //true
        console.log(f1.__proto__.getX === f2.getX); //false
        console.log(f1.getX === Fn.prototype.getX); //false
        console.log(f1.constructor); //function Fn的代码

        f1.getX(); //100
        f1.__proto__.getX();//undefined  这么使用 this指向 原型对象， 这个对象 和其 父链上的对象 中没有x属性 ，所以是undefined
        f2.getY(); //200
        Fn.prototype.getY(); //同上，undefined
    </script>
</body>
</html>